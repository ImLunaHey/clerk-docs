---
title: Route protection | Next.js
description: Learn how to protect the routes in your application 
---

# Route protection

Clerk offers you, the developer, any options to secure the routes in their applications, as well as easy ways to integrate role or permissions based checks. The opt-in nature of Clerk gives you flexibility in how you want to build you application.

This guide will cover:
- protecting routes from users who are not signed in
- integrating your route protection with organization roles and permissions

## Core concepts

### Opt-In 

[`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) provides opt-in protection for your routes. By default no routes will be protected. You will indicate what routes to protect through the Middleware, layouts or even per route/page. 

### Protect via Middleware, routes, pages, or a mixture of all three

With the opt-in approach of `clerkMiddleware()` you are free to protect your routes and pages in the most conveniant way to you.

### Intregration with Organizations and Roles

You can the [`auth().protect()`](/docs/references/nextjs/auth#authorization-with-protect) and [`auth().has()`](/docs/references/nextjs/auth#authorization) methods when creating rules to protect pages. This will integrate with Organization role and permissions, allowing you to protect routes based on the permissions or roles a user has.


## Ensure users are logged in to access a route:w

### Protect using your Route's layout.tsx 

You can use a `layout.tsx` file to protect the entire route, including all children. The following example would protect the entire `/dashboard` and require users to be signed into the application to access the route. 

```tsx filename="app/dashboard/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function Layout(
  { children }: 
  { children: React.ReactNode }
) {
  if (!auth().userId) {
    return auth().redirectToSignIn()
  }
  return <>{children}</>
}
```

### Protect a specific page

You can protect a specific page using our auth() and its helper methods. 

```tsx filename="app/subscribe/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

  if (!auth().userId) {
    return auth().redirectToSignIn()
  }

  return (
    <>
      <h1>Plan Subscription</h1>
      <p>Subscribe to one of our plans, and get access to our service today!</p>
    </>
  );
}
```

### Protect using Middleware

The following will require users to be logged in to access the `/dashboard` route, and if they are not it will redirect to sign the sign-in route.

```tsx filename="middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if ( req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

## Protect your routes using Organization roles or permissions


### Protect a route using layout.tsx

You can use `protect()` and `has()` in a route's `layout.tsx` to protect based on roles or permissions.

<CodeBlockTabs type="router" options={["protect()", "has()"]}>

```tsx filename="app/dashboard/manage-users/layout.tsx" 
import { auth } from "@clerk/nextjs/server";

export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  auth().protect({ permission: "org:test:permission" })
  return (
    <div>{children}</div>
  )
}
```

```tsx filename="app/dashboard/manage-users/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function Layout({ children }: { children: React.ReactNode }) {
  if (!auth().has({ role: "org:admin" })) {
    redirect("/")
  }
  return <>{children}</>
}
```
</CodeBlockTabs>

### Page example

You can use `protect()` and `has()` in a specific page to protect using roles and permissions from organizations.

<CodeBlockTabs type="router" options={["protect()", "has()"]}>
```tsx filename="app/manage-users/page.tsx"
import { auth } from "@clerk/nextjs/server"

export default function Page() {

  auth().protect({ permission: "org:test:permission" })

  return (
    <p>This is a page</p>
  )
}
```

```tsx filename="app/dashboard/manage-users/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

if (!auth().has({ role: "org:admin" })) {
    return <p>You do not have permission to view this page.</p>
  }

  return (
    <>
      <h1>Manage Users</h1>
      <p>Manage your users, invite new users or ban users</p>
    </>
  );
}
```
</CodeBlockTabs>


### Middleware

You can manage your route protection with `clerkMiddleware()` along with `has()` and `protect()` to protect based on organization roles and permissions.

<CodeBlockTabs type="router" options={["protect()", "has()"]}>
```tsx filename="middleware.tsx"
import {
  clerkMiddleware,
  createRouteMatcher,
} from '@clerk/nextjs/server';

const isProtectedRoute = createRouteMatcher([
  '/dashboard'
]);

export default clerkMiddleware((auth, req) => {
  // Restricted to logged in users
  // Logged out users will be redirected to sign-in route
  if (isProtectedRoute(req)) {
    console.log('test', auth().protect())
    auth().protect()
  }
}

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

```tsx filename="app/dashboard/manage-users/page.tsx" 
import {
  clerkMiddleware,
  createRouteMatcher,
} from '@clerk/nextjs/server';

const isProtectedRoute = createRouteMatcher([
  '/dashboard'
]);

export default clerkMiddleware((auth, req) => {
  // restrict protected routes to users with specific permissions 
  if (isProtectedRoute(req)) {
    console.log('test')
    auth().protect(has => {
      return (
        has({ permission: 'org:test:permission' })
      )
    })
  }
}

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```
</CodeBlockTabs>



## Middleware + layout or page

Applications with more complex protection needs may be well suited to use a mix of Middleware and layout or page based protection. Your application may have a `/dashboard` section, but it may also have routes or specific pages that are limited to users with a specific role or permission. In a situation such as this you might enforce that only signed in users can access `/dashboard` in your Middleware, and then add specific role based checks the `layout.tsx` for a route like `app/orgs/layout.tsx"`.

### Middleware + layout example

<CodeBlockTabs type="router" options={["middleware.ts", "app/orgs/layout.tsx"]}>
```tsx filename="middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

```tsx filename="app/orgs/layout.tsx" 
import { auth } from "@clerk/nextjs/server";

export default async function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  auth().protect({ permission: "org:test:permission" })
  return (
    <div>{children}</div>
  )
}
```
</CodeBlockTabs>


### Middleware + page example
<CodeBlockTabs type="router" options={["app/middleware.ts", "app/orgs/page.tsx"]}>

```tsx filename="middleware.tsx"
import { clerkMiddleware } from '@clerk/nextjs/server';
 
export default clerkMiddleware(
  (auth, req) => {
    if ( req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);
 
export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

```tsx filename="app/orgs/page.tsx"
import { auth } from "@clerk/nextjs/server"

export default function Page() {

  auth().protect({ permission: "org:test:permission" })

  return (
    <p>This is a page</p>
  )
}
```
</CodeBlockTabs>
