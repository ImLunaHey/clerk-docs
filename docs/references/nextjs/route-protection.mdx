---
title: Route protection | Next.js
description: Learn how to protect the routes in your application 
---

# Route protection

Clerk offers you, the developer, any options to secure the routes in their applications, as well as easy ways to integrate role or permissions based checks. The opt-in nature of Clerk gives you flexibility in how you want to build you application.

This guide will cover:
- protecting routes from users who are not signed in
- integrating your route protection with organization roles and permissions

## Core concepts

### Opt-In 

`clerkMiddleware()` provides opt-in protection for your routes. By default no routes will be protected. You will indicate what routes to protect through the Middleware, layouts or even per route/page. 

### Protect via Middleware, routes, pages, or a mixture of all three

With the opt-in approach of `clerkMiddleware()` you are free to protect your routes and pages in the most conveniant way to you.

### Intregration with Organizations and Roles

`clerkMiddleware()` provides a new `auth().protect()` method that can be used when creating rules to protect pages. This will integrate with Organization role and permissions, allowing you to protect routes based on the permissions or roles a user has.


## Ensure users are logged in to access a route

### Protect using your Route's layout.tsx 

You can use a `layout.tsx` file to protect the entire route, including all children. The following example would protect the entire `/dashboard` and require users to be signed into the application to access the route. 

```tsx filename="app/src/dashboard/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function Layout(
  { children }: 
  { children: React.ReactNode }
) {
  if (!auth().userId) {
    return auth().redirectToSignIn()
  }
  return <>{children}</>
}
```

### Protect a specific page

You can protect a specific page using our auth() and its helper methods. 

```tsx filename="app/src/subscribe/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

  if (!auth().userId) {
    return auth().redirectToSignIn()
  }

  return (
    <>
      <h1>Plan Subscription</h1>
      <p>Subscribe to one of our plans, and get access to our service today!</p>
    </>
  );
}
```

### Protect using Middleware

The following will require users to be logged in to access the `/dashboard` route, and if they are not it will redirect to sign the sign-in route.

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if ( req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```

## Protect your routes using Organization roles or permissions


### Protect a route using layout.tsx

<CodeBlockTabs type="router" options={["protect()", "has()"]}>

```tsx filename="app/src/dashboard/manage-users/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function Layout(
  { children }: 
  { children: React.ReactNode }
) {
  const { userId } = auth().protect({ permission: "org:domains:delete"}, { redirectUrl: // PATHNAME})
  return <>{children}</>
}
```

```tsx filename="app/src/dashboard/manage-users/layout.tsx" 
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function Layout({ children }: { children: React.ReactNode }) {
  if (!auth().has({ role: "org:admin" })) {
    redirect("/")
  }
  return <>{children}</>
}
```

</CodeBlockTabs>



### Page example

```tsx filename="app/src/dashboard/manage-users/page.tsx" 
import { auth } from '@clerk/nextjs/server'

export default function Page() {

if (!auth().has({ role: "org:admin" })) {
    return <p>You do not have permission to view this page.</p>
  }

  return (
    <>
      <h1>Manage Users</h1>
      <p>Manage your users, invite new users or ban users</p>
    </>
  );
}
```

## Middleware + layout or page

Applications with more complex protection needs may be well suited to use a mix of Middleware and layout or page based protection. Your application may have a `/dashboard` section, but within that it might have routes or specific pages that are limited to users with a specific role or permission. In a situation such as this you might enforce that only signed in users can access `/dashboard` in your Middleware, and then add specific role based checks the `layout.tsx` for a route like `/dashboard/manage-users`.

### Middleware + layout example

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```





### Middleware + page example

```tsx filename="app/src/middleware.ts"
import { clerkMiddleware } from '@clerk/nextjs/server';

export default clerkMiddleware(
  (auth, req) => {
    if (  req.nextUrl.pathname.startsWith('/dashboard')) {
      auth().protect();
    }
  }
);

export const config = {
  matcher: ['/((?!.*\\..*|_next).*)', '/', '/(api|trpc)(.*)'],
};
```


## Layout or page only

Since Clerk's `clerkMiddleware()` is purely opt-in, meaning if you don't add any specific protection to the Middleware all routes are by default public. This allows you to then enforce protections via only layouts or even pages and keep your protection logic scoped to that specific area it governs, in your application.


